# 执行所依赖的文件介绍

- word_dict.txt 一个单词作为专有名词。不能包含空格。因为代码中的逻辑是依据单词匹配和替换（先根据空格分词，再进行匹配）。以 `#` 分割。

- comp_word_dict.txt 复合单词组成的专有名词，允许包含空格。代码中的识别方式是字符串匹配和替换。以 `#` 分割。
进一步的，当一行中仅仅包含这个词时，则不进行翻译的API调用。

- manual_trans_word_dict.txt 复合单词组成的专有名词，允许包含空格。代码中的识别方式是字符串和替换。以 `#` 分割。
如果命中这个文件里的单词，则不进行翻译的API调用。

- sp_word_dict.txt 当检测到 manual_trans_word_dict 中词时，要在 sp_word_dict.txt 这个文件中检测。因为有些常用词在日常的翻译和游戏环境上下文的翻译，是不一样的。必须要把这两种情况区分开。

- name_dict.txt 存放姓名的翻译。以 `#` 分割。

- tra/ 存放需要翻译的原始的.tra文件。需要自己建目录。

- output/ 存放翻译后的.tra文件。需要自己建目录。

- appconf.ini 配置文件，放翻译API的相关配置信息。

通过执行初始化shell脚本 `init_shell.sh` 后，在 `appconf.ini` 文件中加入相关信息。

- readlog.txt 记录上次执行结束点功能。每次任务时，会先读 readlog.txt，找到上一次的记录点，然后从该位置开始执行。
每次任务执行成功后，调用 log.done(), 在文件末尾写入 'done' 记录，表示本次任务全部执行完。下次再执行时，则会忽略 readlog.txt 中全部内容。
readlog.txt 的格式为 `filename|line_num`
filename 表示读的文件
line_num 表示下一次执行的行号(在代码中，即`当前行+1`) 
例如，假如上一次在成功写入第10行后，接口报错退出，那么readlog.txt 中最后一条记录是 `file|11`

- 在 simple_main.py 中，增加了 `trans_and_write_append` 方法，作用是每翻译一行，立即写文件。 
这在API容易出错的情况下，这个方案可以解决出错导致整个文件没保存的部分白白浪费的情况。 
由于每次调用都有一定时延，所以不会特别频繁写文件。
这个方案做到了断点重续，从失败位置开始继续翻译，而不是从文件头开始重新翻译，提升了效率。

- 
项目中给出了一个以上若干文件写法的例子，是翻译一个 `威尔逊编年史`mod 的实现。

### 注意

1.

由于实现机制是字符串匹配，所以如果 `*_dict.txt` 文件中(comp_word_dict.txt, manual_trans_word_dict.txt)有 key 互相包含时，比如 `aaa包含a`，这时就应该将 aaa 写在 a 的前面，优先被遍历到，而不会干扰到 a 的识别。

例如，文件中配置了下面2项
```
THACO#零级命中值
AC#护甲值
```
就应该将 THACO 写在 AC 前面，否则，AC会先识别并完成替换，那么 THACO 就无法正确识别。

2.

会自动忽略 SETUP.TRA 文件。因为自己测试时，翻译这个文件会导致 mod 安装界面乱码。
所以，翻译完成后，需要手动复制 SETUP.TRA 文件到需要安装的 mod 的 schinese/ 目录下。
